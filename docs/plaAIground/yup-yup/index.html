<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Voice Notes - Second Brain</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      padding: 20px;
      max-width: 600px;
      margin: 0 auto;
      background-color: #f7f9fc;
    }
    
    h1 {
      text-align: center;
      color: #333;
    }
    
    .app-container {
      background: white;
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    
    .control-panel {
      display: flex;
      justify-content: center;
      margin-bottom: 20px;
    }
    
    button {
      background-color: #1DB954; /* Spotify green */
      color: white;
      border: none;
      padding: 15px 30px;
      margin: 0 10px;
      border-radius: 30px;
      cursor: pointer;
      font-weight: bold;
      font-size: 1rem;
      transition: all 0.2s;
    }
    
    button:hover {
      background-color: #1aa34a;
      transform: scale(1.05);
    }
    
    button:disabled {
      background-color: #ccc;
      cursor: not-allowed;
      transform: none;
    }
    
    button.record {
      background-color: #e74c3c;
    }
    
    button.record:hover {
      background-color: #c0392b;
    }
    
    .status {
      text-align: center;
      margin: 10px 0;
      font-weight: bold;
      height: 1.5em;
    }
    
    .transcript-area {
      width: 100%;
      min-height: 100px;
      margin: 20px 0;
      padding: 15px;
      border: 1px solid #ddd;
      border-radius: 8px;
      box-sizing: border-box;
      font-size: 1rem;
    }
    
    .note-list {
      margin-top: 30px;
    }
    
    .note-item {
      background-color: #f0f0f0;
      padding: 15px;
      margin-bottom: 10px;
      border-radius: 8px;
      position: relative;
    }
    
    .note-metadata {
      font-size: 0.8rem;
      color: #666;
      margin-top: 5px;
    }
    
    .note-controls {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 10px;
    }
    
    .note-controls button {
      padding: 5px 10px;
      font-size: 0.8rem;
    }
    
    .delete-btn {
      background-color: #e74c3c;
    }
    
    .spotify-container {
      margin: 20px 0;
      padding: 15px;
      background-color: #f0f0f0;
      border-radius: 8px;
      text-align: center;
    }
    
    .spotify-status {
      font-weight: bold;
    }
    
    /* Mobile optimizations */
    @media (max-width: 480px) {
      body {
        padding: 10px;
      }
      
      button {
        padding: 12px 20px;
        font-size: 0.9rem;
      }
    }
  </style>
</head>
<body>
  <div class="app-container">
    <h1 id="voice-notes">Voice Notes</h1>
    
    <div id="spotify-connect" class="spotify-container">
      <p>Spotify integration is <span class="spotify-status">not connected</span></p>
      <button id="spotify-login-btn">Connect Spotify</button>
    </div>
    
    <div class="voice-trigger-info" style="text-align: center; margin: 10px 0; padding: 15px; background-color: #f0f7ff; border-radius: 8px;">
      <p>Say <strong>"yup yup"</strong> while listening to start recording automatically!</p>
      <p style="color: #666; font-size: 0.9rem; margin-top: 10px;">
        <strong>Troubleshooting:</strong> Make sure you're online and have granted microphone permissions.
        If you get a network error, wait for automatic reconnection attempts or try using Chrome (works best).
      </p>
      <p style="color: #2e7d32; font-size: 0.9rem; margin-top: 10px;">
        <strong>Spotify Feature:</strong> When you stop recording, your Spotify track will automatically rewind by 15 seconds.
        This helps you capture the context of what you were listening to.
      </p>
      <div id="browser-compatibility" style="margin-top: 12px; font-size: 0.85rem; color: #555;"></div>
    </div>
    
    <div class="control-panel">
      <button id="start-btn">Start Listening</button>
      <button id="record-btn" class="record" disabled>Record Note</button>
    </div>
    
    <p id="status" class="status">Ready to start</p>
    
    <textarea id="transcript" class="transcript-area" placeholder="Your transcribed notes will appear here..." readonly></textarea>
    
    <div class="control-panel">
      <button id="save-btn" disabled>Save Note</button>
      <button id="clear-btn" disabled>Clear</button>
    </div>
    
    <div class="note-list" id="notes-container">
      <h2 id="saved-notes">Saved Notes</h2>
      <!-- Notes will be added here dynamically -->
    </div>
  </div>

  <script>
    // DOM Elements
    const startBtn = document.getElementById('start-btn');
    const recordBtn = document.getElementById('record-btn');
    const saveBtn = document.getElementById('save-btn');
    const clearBtn = document.getElementById('clear-btn');
    const spotifyLoginBtn = document.getElementById('spotify-login-btn');
    const statusDisplay = document.getElementById('status');
    const transcriptArea = document.getElementById('transcript');
    const notesContainer = document.getElementById('notes-container');
    
    // Speech recognition setup
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    let recognition;
    let recognitionAttempts = 0;
    const MAX_RECOGNITION_ATTEMPTS = 3;
    
    if (SpeechRecognition) {
      setupSpeechRecognition();
    } else {
      statusDisplay.textContent = 'Speech recognition not supported in this browser.';
      startBtn.disabled = true;
    }
    
    function setupSpeechRecognition() {
      recognition = new SpeechRecognition();
      recognition.continuous = true;
      recognition.interimResults = true;
      recognition.lang = 'en-US'; // Set language
      recognition.maxAlternatives = 3; // Get multiple alternatives to improve trigger detection
    }
    
    // App state
    let isListening = false;
    let isRecording = false;
    let spotifyConnected = false;
    let spotifyToken = null;
    let currentSpotifyTrack = null;
    let currentPlaybackPosition = 0; // Store the current playback position
    const REWIND_SECONDS = 15; // How many seconds to rewind when stopping recording
    
    // Voice trigger settings
    const TRIGGER_PHRASE = "yup yup";
    const TRIGGER_CONFIDENCE = 0.7; // Minimum confidence level
    
    // Load saved notes from localStorage
    loadNotes();
    
    // Check browser compatibility
    checkBrowserCompatibility();
    
    // Event listeners
    startBtn.addEventListener('click', toggleListening);
    recordBtn.addEventListener('click', toggleRecording);
    saveBtn.addEventListener('click', saveNote);
    clearBtn.addEventListener('click', clearTranscript);
    spotifyLoginBtn.addEventListener('click', connectToSpotify);
    
    // Check if returning from Spotify auth
    checkSpotifyAuth();
    
    // Functions
    function toggleListening() {
      if (!isListening) {
        // Reset attempts counter when starting fresh
        recognitionAttempts = 0;
        
        // Request microphone permission explicitly first
        navigator.mediaDevices.getUserMedia({ audio: true })
          .then(() => {
            // Microphone permission granted, start recognition
            startSpeechRecognition();
          })
          .catch(error => {
            console.error('Microphone permission denied:', error);
            statusDisplay.textContent = 'Error: Microphone access denied. Please allow microphone access.';
          });
      } else {
        // Stop listening
        stopSpeechRecognition();
      }
    }
    
    function startSpeechRecognition() {
      try {
        // Recreate recognition instance to avoid stale state
        setupSpeechRecognition();
        
        recognition.start();
        isListening = true;
        startBtn.textContent = 'Stop Listening';
        statusDisplay.textContent = 'Listening...';
        recordBtn.disabled = false;
        recognitionAttempts = 0; // Reset attempts counter on successful start
      } catch (error) {
        console.error('Error starting recognition:', error);
        handleRecognitionError(error);
      }
    }
    
    function stopSpeechRecognition() {
      try {
        recognition.stop();
      } catch (error) {
        console.error('Error stopping recognition:', error);
      }
      isListening = false;
      startBtn.textContent = 'Start Listening';
      statusDisplay.textContent = 'Not listening';
      recordBtn.disabled = true;
      if (isRecording) {
        toggleRecording();
      }
      recognitionAttempts = 0; // Reset attempts counter
    }
    
    function handleRecognitionError(error) {
      recognitionAttempts++;
      
      if (recognitionAttempts < MAX_RECOGNITION_ATTEMPTS) {
        statusDisplay.textContent = `Recognition error. Retrying (${recognitionAttempts}/${MAX_RECOGNITION_ATTEMPTS})...`;
        // Wait a moment before retrying
        setTimeout(() => startSpeechRecognition(), 1000);
      } else {
        statusDisplay.textContent = 'Unable to start speech recognition. Try using a different browser (Chrome works best).';
        isListening = false;
        startBtn.textContent = 'Start Listening';
      }
    }
    
    function toggleRecording() {
      if (!isRecording) {
        // Start recording
        isRecording = true;
        recordBtn.textContent = 'Stop Recording';
        statusDisplay.textContent = 'Recording note...';
        transcriptArea.value = '';
        saveBtn.disabled = true;
        clearBtn.disabled = true;
        
        // Play audio feedback
        playAudioFeedback('start');
        
        // If Spotify is connected, pause it
        if (spotifyConnected) {
          pauseSpotify();
        }
      } else {
        // Stop recording
        isRecording = false;
        recordBtn.textContent = 'Record Note';
        statusDisplay.textContent = 'Note recorded';
        saveBtn.disabled = false;
        clearBtn.disabled = false;
        
        // Play audio feedback
        playAudioFeedback('stop');
        
        // If Spotify is connected, resume it
        if (spotifyConnected) {
          resumeSpotify();
        }
      }
    }
    
    // Audio feedback function
    function playAudioFeedback(type) {
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      if (type === 'start') {
        // Higher pitch for start
        oscillator.frequency.value = 880; // A5
        gainNode.gain.value = 0.2;
        oscillator.start();
        setTimeout(() => {
          oscillator.stop();
        }, 200);
      } else if (type === 'stop') {
        // Lower pitch for stop
        oscillator.frequency.value = 440; // A4
        gainNode.gain.value = 0.2;
        oscillator.start();
        setTimeout(() => {
          oscillator.stop();
        }, 200);
      }
    }
    
    function saveNote() {
      if (transcriptArea.value.trim() === '') {
        statusDisplay.textContent = 'Cannot save empty note';
        return;
      }
      
      const note = {
        id: Date.now(),
        text: transcriptArea.value.trim(),
        timestamp: new Date().toISOString(),
        source: spotifyConnected && currentSpotifyTrack ? 
          `Spotify - ${currentSpotifyTrack.name} by ${currentSpotifyTrack.artists.map(a => a.name).join(', ')}` :
          'Manual note'
      };
      
      // Save to localStorage
      const notes = JSON.parse(localStorage.getItem('secondBrainNotes') || '[]');
      notes.push(note);
      localStorage.setItem('secondBrainNotes', JSON.stringify(notes));
      
      // Add to UI
      addNoteToUI(note);
      
      // Clear transcript
      transcriptArea.value = '';
      statusDisplay.textContent = 'Note saved';
      saveBtn.disabled = true;
      clearBtn.disabled = true;
    }
    
    function clearTranscript() {
      transcriptArea.value = '';
      statusDisplay.textContent = 'Transcript cleared';
      saveBtn.disabled = true;
      clearBtn.disabled = true;
    }
    
    function loadNotes() {
      const notes = JSON.parse(localStorage.getItem('secondBrainNotes') || '[]');
      
      // Clear container first
      const notesHeader = document.createElement('h2');
      notesHeader.textContent = 'Saved Notes';
      notesContainer.innerHTML = '';
      notesContainer.appendChild(notesHeader);
      
      // Add notes to UI
      notes.forEach(note => addNoteToUI(note));
    }
    
    function addNoteToUI(note) {
      const noteElement = document.createElement('div');
      noteElement.className = 'note-item';
      noteElement.dataset.id = note.id;
      
      const dateOptions = { year: 'numeric', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' };
      const formattedDate = new Date(note.timestamp).toLocaleDateString('en-US', dateOptions);
      
      noteElement.innerHTML = `
        <div class="note-text">${note.text}</div>
        <div class="note-metadata">
          <div>Source: ${note.source}</div>
          <div>Created: ${formattedDate}</div>
        </div>
        <div class="note-controls">
          <button class="edit-btn">Edit</button>
          <button class="delete-btn">Delete</button>
        </div>
      `;
      
      // Add event listeners for edit and delete
      noteElement.querySelector('.delete-btn').addEventListener('click', () => deleteNote(note.id));
      noteElement.querySelector('.edit-btn').addEventListener('click', () => editNote(note.id));
      
      // Add to container
      notesContainer.appendChild(noteElement);
    }
    
    function deleteNote(id) {
      // Remove from localStorage
      let notes = JSON.parse(localStorage.getItem('secondBrainNotes') || '[]');
      notes = notes.filter(note => note.id !== id);
      localStorage.setItem('secondBrainNotes', JSON.stringify(notes));
      
      // Remove from UI
      const noteElement = document.querySelector(`.note-item[data-id="${id}"]`);
      if (noteElement) {
        noteElement.remove();
      }
      
      statusDisplay.textContent = 'Note deleted';
    }
    
    function editNote(id) {
      // Get note data
      const notes = JSON.parse(localStorage.getItem('secondBrainNotes') || '[]');
      const note = notes.find(note => note.id === id);
      
      if (note) {
        // Load into textarea
        transcriptArea.value = note.text;
        saveBtn.disabled = false;
        clearBtn.disabled = false;
        
        // Remove old note
        deleteNote(id);
        
        statusDisplay.textContent = 'Editing note';
      }
    }
    
    // Speech recognition event handlers
    if (recognition) {
      recognition.onresult = (event) => {
        let interimTranscript = '';
        let finalTranscript = '';
        
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const transcript = event.results[i][0].transcript.toLowerCase();
          const confidence = event.results[i][0].confidence;
          
          if (event.results[i].isFinal) {
            finalTranscript += transcript;
            
            // Check for trigger phrase when not recording
            if (!isRecording && transcript.includes(TRIGGER_PHRASE) && confidence >= TRIGGER_CONFIDENCE) {
              console.log('Trigger phrase detected!', transcript);
              statusDisplay.textContent = 'Trigger phrase detected! Starting recording...';
              
              // Small delay to avoid capturing the trigger phrase itself
              setTimeout(() => {
                toggleRecording();
              }, 500);
            }
          } else {
            interimTranscript += transcript;
          }
        }
        
        // Only update transcript if recording
        if (isRecording) {
          transcriptArea.value = finalTranscript || interimTranscript;
          
          if (finalTranscript) {
            saveBtn.disabled = false;
            clearBtn.disabled = false;
          }
        }
      };
      
      recognition.onerror = (event) => {
        console.error('Speech recognition error', event.error);
        
        if (event.error === 'network') {
          statusDisplay.textContent = 'Network error: Attempting to reconnect...';
          
          // Only increment the attempts counter for network errors
          recognitionAttempts++;
          
          if (recognitionAttempts < MAX_RECOGNITION_ATTEMPTS) {
            // Attempt to restart after a short delay, with progressive backoff
            const delayMs = 1000 * recognitionAttempts; // 1s, 2s, 3s
            
            statusDisplay.textContent = `Network error: Retrying in ${delayMs/1000} seconds (${recognitionAttempts}/${MAX_RECOGNITION_ATTEMPTS})`;
            
            setTimeout(() => {
              if (isListening) {
                try {
                  // Create a fresh recognition instance to avoid stale network connections
                  setupSpeechRecognition();
                  recognition.start();
                  statusDisplay.textContent = 'Reconnected. Listening...';
                } catch (e) {
                  console.error('Could not restart recognition', e);
                  handleRecognitionError(e);
                }
              }
            }, delayMs);
          } else {
            statusDisplay.textContent = 'Network error: Could not establish connection. Try refreshing the page or using a different browser.';
            isListening = false;
            startBtn.textContent = 'Start Listening';
          }
        } else if (event.error === 'not-allowed') {
          statusDisplay.textContent = 'Error: Microphone access denied. Please allow microphone access.';
          isListening = false;
          startBtn.textContent = 'Start Listening';
        } else if (event.error === 'no-speech') {
          // Just a quiet period, no need to increment attempt counter
          if (isListening) {
            try {
              recognition.start();
            } catch (e) {
              console.error('Could not restart recognition after no-speech', e);
              // Don't increment attempts for no-speech errors
              handleRecognitionError(e);
            }
          }
        } else {
          statusDisplay.textContent = `Error: ${event.error}. Try refreshing the page.`;
          isListening = false;
          startBtn.textContent = 'Start Listening';
        }
      };
      
      recognition.onend = () => {
        if (isListening) {
          // Restart if we're supposed to be listening
          try {
            recognition.start();
          } catch (e) {
            console.error('Error restarting recognition in onend handler:', e);
            // Use a short timeout to prevent rapid retries if there's a persistent error
            setTimeout(() => {
              if (isListening) {
                handleRecognitionError(e);
              }
            }, 1000);
          }
        }
      };
    }
    
    // Spotify Integration
    function connectToSpotify() {
      // Spotify API credentials with your client ID hardcoded
      const client_id = '39a9e6d4d9f24dcd8dcbecd89118649b';
      const redirect_uri = window.location.origin + window.location.pathname;
      const scope = 'user-read-playback-state user-modify-playback-state user-read-currently-playing';
      
      // Save redirect state
      localStorage.setItem('spotifyAuthPending', 'true');
      
      // Redirect to Spotify auth
      window.location.href = `https://accounts.spotify.com/authorize?client_id=${client_id}&response_type=token&redirect_uri=${encodeURIComponent(redirect_uri)}&scope=${encodeURIComponent(scope)}`;
    }
    
    function checkSpotifyAuth() {
      // Check if we're returning from Spotify auth
      const hashParams = getHashParams();
      if (hashParams.access_token) {
        spotifyToken = hashParams.access_token;
        spotifyConnected = true;
        localStorage.setItem('spotifyToken', spotifyToken);
        localStorage.setItem('spotifyTokenExpiry', Date.now() + (hashParams.expires_in * 1000));
        
        // Clear hash from URL
        window.history.replaceState(null, null, ' ');
        
        updateSpotifyUI();
        getCurrentTrack();
      } else {
        // Check if we have a valid token in localStorage
        const savedToken = localStorage.getItem('spotifyToken');
        const tokenExpiry = localStorage.getItem('spotifyTokenExpiry');
        
        if (savedToken && tokenExpiry && Date.now() < parseInt(tokenExpiry)) {
          spotifyToken = savedToken;
          spotifyConnected = true;
          updateSpotifyUI();
          getCurrentTrack();
        }
      }
    }
    
    function getHashParams() {
      const hashParams = {};
      let e, r = /([^&;=]+)=?([^&;]*)/g,
          q = window.location.hash.substring(1);
          
      while (e = r.exec(q)) {
        hashParams[e[1]] = decodeURIComponent(e[2]);
      }
      
      return hashParams;
    }
    
    function updateSpotifyUI() {
      document.querySelector('.spotify-status').textContent = spotifyConnected ? 'connected' : 'not connected';
      spotifyLoginBtn.textContent = spotifyConnected ? 'Refresh Connection' : 'Connect Spotify';
      
      if (spotifyConnected) {
        const spotifyContainer = document.getElementById('spotify-connect');
        
        // Check if track info element already exists
        let trackInfoElement = document.getElementById('current-track-info');
        if (!trackInfoElement) {
          trackInfoElement = document.createElement('div');
          trackInfoElement.id = 'current-track-info';
          trackInfoElement.style.marginTop = '10px';
          spotifyContainer.appendChild(trackInfoElement);
        }
      }
    }
    
    function getCurrentTrack() {
      if (!spotifyConnected || !spotifyToken) return;
      
      fetch('https://api.spotify.com/v1/me/player/currently-playing', {
        headers: {
          'Authorization': `Bearer ${spotifyToken}`
        }
      })
      .then(response => {
        if (response.status === 204) {
          // No track currently playing
          return null;
        }
        return response.json();
      })
      .then(data => {
        if (data && data.item) {
          currentSpotifyTrack = data.item;
          // Store current playback position (in milliseconds)
          currentPlaybackPosition = data.progress_ms;
          
          const trackInfoElement = document.getElementById('current-track-info');
          if (trackInfoElement) {
            const formattedTime = formatTime(Math.floor(data.progress_ms / 1000));
            trackInfoElement.innerHTML = `
              <p>Now playing: <strong>${data.item.name}</strong> by ${data.item.artists.map(a => a.name).join(', ')}</p>
              <p>Current position: ${formattedTime}</p>
            `;
          }
        }
      })
      .catch(error => {
        console.error('Error getting current track', error);
        if (error.status === 401) {
          // Token expired
          spotifyConnected = false;
          updateSpotifyUI();
        }
      });
    }
    
    function pauseSpotify() {
      if (!spotifyConnected || !spotifyToken) return;
      
      fetch('https://api.spotify.com/v1/me/player/pause', {
        method: 'PUT',
        headers: {
          'Authorization': `Bearer ${spotifyToken}`
        }
      })
      .then(() => {
        console.log('Spotify paused');
      })
      .catch(error => {
        console.error('Error pausing Spotify', error);
      });
    }
    
    function resumeSpotify() {
      if (!spotifyConnected || !spotifyToken) return;
      
      // Calculate new position by rewinding the stored position by REWIND_SECONDS
      let rewindPositionMs = currentPlaybackPosition - (REWIND_SECONDS * 1000);
      
      // Make sure we don't go below zero
      rewindPositionMs = Math.max(0, rewindPositionMs);
      
      // Format time for logging
      const formattedOriginalTime = formatTime(Math.floor(currentPlaybackPosition / 1000));
      const formattedRewindTime = formatTime(Math.floor(rewindPositionMs / 1000));
      
      console.log(`Rewinding from ${formattedOriginalTime} to ${formattedRewindTime}`);
      
      // First resume playback
      fetch('https://api.spotify.com/v1/me/player/play', {
        method: 'PUT',
        headers: {
          'Authorization': `Bearer ${spotifyToken}`
        }
      })
      .then(() => {
        console.log('Spotify resumed, now seeking to rewound position');
        
        // Then seek to the rewound position
        return fetch(`https://api.spotify.com/v1/me/player/seek?position_ms=${rewindPositionMs}`, {
          method: 'PUT',
          headers: {
            'Authorization': `Bearer ${spotifyToken}`
          }
        });
      })
      .then(() => {
        console.log(`Spotify rewound ${REWIND_SECONDS} seconds to ${formattedRewindTime}`);
        
        // Update UI to show user what happened
        statusDisplay.textContent = `Spotify rewound ${REWIND_SECONDS} seconds`;
        
        // Update current track info after a moment to reflect new position
        setTimeout(getCurrentTrack, 1000);
      })
      .catch(error => {
        console.error('Error with Spotify resume/rewind:', error);
      });
    }
    
    // Helper function to format seconds into MM:SS format
    function formatTime(totalSeconds) {
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      return `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }
    
    // Function to check browser compatibility and provide helpful messages
    function checkBrowserCompatibility() {
      const browserCompatibilityEl = document.getElementById('browser-compatibility');
      const browser = detectBrowser();
      
      if (browser === 'chrome') {
        browserCompatibilityEl.innerHTML = '✅ You\'re using Chrome - speech recognition should work well.';
        browserCompatibilityEl.style.color = '#2e7d32';
      } else if (browser === 'firefox') {
        browserCompatibilityEl.innerHTML = '⚠️ Firefox support for speech recognition can be inconsistent. If you experience issues, try Chrome.';
        browserCompatibilityEl.style.color = '#ff9800';
      } else if (browser === 'safari') {
        browserCompatibilityEl.innerHTML = '⚠️ Safari\'s speech recognition support may be limited. If you experience issues, try Chrome.';
        browserCompatibilityEl.style.color = '#ff9800';
      } else {
        browserCompatibilityEl.innerHTML = '⚠️ Speech recognition works best in Chrome.';
        browserCompatibilityEl.style.color = '#ff9800';
      }
    }
    
    // Helper function to detect browser
    function detectBrowser() {
      const userAgent = navigator.userAgent.toLowerCase();
      
      if (userAgent.indexOf('chrome') > -1 && userAgent.indexOf('edg') === -1) {
        return 'chrome';
      } else if (userAgent.indexOf('firefox') > -1) {
        return 'firefox';
      } else if (userAgent.indexOf('safari') > -1 && userAgent.indexOf('chrome') === -1) {
        return 'safari';
      } else if (userAgent.indexOf('edg') > -1) {
        return 'edge';
      } else {
        return 'unknown';
      }
    }
    
    // Poll for current track every 5 seconds if connected
    setInterval(() => {
      if (spotifyConnected) {
        getCurrentTrack();
      }
    }, 5000);
  </script>
</body>
</html>